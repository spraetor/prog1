---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Julia 1.11
  language: julia
  name: julia-1.11
---

# Gleitkommazahlen

## Rationale Zahlen


## Festkommadarstellung

Die **Festkommadarstellung** (auch *Festpunktdarstellung* = *fixed-point representation*) des Betrags einer
*endlich darstellbaren* rationalen Zahl $f$ zu einer Basis $b\in\mathbb{N}\setminus\{0, 1\}$ besteht im
Allgemeinen aus einer Anzahl von Ziffern für ihren ganzzahligen Anteil (hier $k$ Vorkommastellen)
und einer Anzahl von Ziffern für ihren gebrochenen Anteil (hier $l$ Nachkommastellen):

$$
[m_{-k+1} m_{-k+2}\cdots m_{-2} m_{-1} m_0 . m_{1} m_{2}\cdots m_{l}]_b = \sum_{i=-k+1}^{l} m_i\cdot b^{i} =: f
$$

wobei die Ziffern $m_i\in\{0,1,2,\ldots,b-1\}$ sind.

```{note}
Es soll hier, wie in allen Programmiersprachen und allgemein bei der Notation von Zahlen international üblich,
zur Trennung des ganzzahligen vom gebrochenen Anteil immer ein (*Dezimal-*/*Binär-*/*Basis b-*)*Punkt* verwendet werden
und *kein Komma*. Die üblichen deutschen Begriffe *Vorkommastelle(n)* und *Nachkommastelle(n)* werden aber beibehalten.
```

Die Ziffern im ganzzahligen Anteil der Zahl haben einen Indexwert in $\{-k+1, -k+2,\ldots,-2,-1,0\}$. Dieser Anteil darf auch
leer sein, wenn der gerbrochene Anteil mindestens eine Ziffer enthält. Die Ziffern mit negativen Indizes $\{1,2,\ldots,l\}$
umfassen den gebrochenen Anteil der Zahl. Auch dieser Anteil darf leer sein, wenn der ganzzahlige Anteil mindestens eine
Ziffer enthält.

Unnötige Nullziffern am Anfang des ganzzahligen Bereichs, z.B. $m_{-k+1}=0$, oder am Ende des gebrochenen Zahlenbereichs, z.B. $m_l=0$,
werden typischerweise weggelassen. Allerdings kann das Weglassen von Ziffern nicht über den Nullpunkt hinausgehen. Dieser ist wichtig, um die
Gewichte $b^i$ klar bestimmen zu können. Man bezeichnet die zusätzlichen Nullziffern vor oder hinter dem Punkt auch als
*Füllziffern* und die ersten Ziffern vor bzw. hinter dem Komma die nicht Null sind als *signifikante Ziffern*.

```{note}
Die hier vorgestellten Regeln entsprechen der *angelsächsischen Gepflogenheit*, auf Ziffern
nach dem Punkt zu verzichten, wenn es keinen gebrochenen Anteil gibt, und auf Ziffern
vor dem Punkt zu verzichten, wenn es keinen ganzzahligen Anteil gibt. Beide Bedingungen
gleichzeitig erfüllt nur die Null, die natürlich trotzdem mit (mindestens) einer Ziffer
geschrieben werden muss: `0.` oder `.0` oder `0.0` kommen in Frage. (Die theoretisch denkbare
minimalistische Darstellung der Null ganz ohne Ziffern nur als ein Punkt würde in der
Praxis gewiss zu Problemen führen.)
```

```{hint}
In vielen Programmiersprachen werden Festkommazahlen daran identifiziert, dass ein Punkt `.` in deren Darstellung enthalten ist.
Die Ausnahme bildet die sogenannte wissenschaftliche Notation (*scientific notation*) als Festkommazahl mit Exponententeil.
Dabei wird eine Festkommazahl (oder auch ganze Zahl) mit einem Buchstaben `e` oder `E` und darauf folgend einem ganzzahligen Exponentenwert
geschrieben (potenziell inklusive Vorzeichen), z.B. `123e-4 = 123.e-4 = 123.0e-4 = 0.0123 = .123E-1 = 0.00123E1 = 0.00123E+1`.
All diese Festkomma-*Literale* entsprechen der Zahl $1.23 \cdot 10^{-2}$.
```

Um eine gegebene Zahl in eine spezifische Festkommadarstellung zu überführen, kann man einen Algorithmus ähnlich dem Basiskonvertierungsalgorithmus von natürlichen Zahlen anwenden. Wir betrachten hier wiederum nur positive Zahlen.

```{prf:algorithm} Konvertierung in Festkommadarstellung
:label: alg-festkommadarstellung

Die Konversion des ganzzahligen Anteils vor dem Punkt erfolgt entsprechend der Basiskonversion natürlicher Zahlen {prf:ref}`alg-basis-konvertierung`.

Die Konversion des gebrochenen Anteils nach dem Punkt zur Zielbasis $b$ erfolgt mit folgendem
Algorithmus:

*Eingabe:* Ausgangszahl $a$, Basis $b$

1. Ausgangszahl $a$ mit Zielbasis $b$ multiplizieren.
2. Ganzzahligen Anteil des Ergebnisses notieren.
3. Falls der Nachkommaanteil gleich 0 ist, dann beende Algorithmus und springe zur Ausgabe.
4. Der Nachkommaanteil wird zur neuen Ausgangszahl $a$. Fahre fort mit Schritt 1.

*Ausgabe:* Die notierten Ziffern ergeben in der generierten Reihenfolge die Nachkommastellen.
```

```{exercise}
:label: float-conversion
Konvertiere die Dezimalzahl $0.8125$ in die Binärdarstellung.
```
```{solution} float-conversion
$$
0.8125 \cdot 2 &= \underline{1}.625 \\
0.625 \cdot 2 &= \underline{1}.25 \\
0.25 \cdot 2 &= \underline{0}.5 \\
0.5 \cdot 2 &= \underline{1}.0
$$

Das Ergebnis ist $[0.8125]_{10} = [0.1101]_2$.
```


```{exercise}
:label: float-conversion-inv

Rückkonversion: Gegeben ist die Binärzahl $[0.1101]_2$. Konvertiere sie in die Dezimaldarstellung ($10 = [1010]_2$).
```

```{solution} float-conversion-inv
Die Rechnung erfolgt binär:

$$
0.1101 \cdot 1010 &= \underline{1000}.001 \\
0.001 \cdot 1010 &= \underline{1}.01 \\
0.01 \cdot 1010 &= \underline{10}.1 \\
0.1 \cdot 1010 &= \underline{101}.0
$$

wegen $[1000]_2=8$, $[1]_2 = 1$, $[10]_2 = 2$ und $[101]_2 = 5$ folgt $[0.1101]_2=[0.8125]_{10}$.
```

```{prf:example} Konversion der Dezimalzahl $0.1$ in die Binärdarstellung
$$
0.1 \cdot 2 &= \underline{0}.2 \\
0.2 \cdot 2 &= \underline{0}.4 \\
0.4 \cdot 2 &= \underline{0}.8 \\
0.8 \cdot 2 &= \underline{1}.6 \\
0.6 \cdot 2 &= \underline{1}.2 \\
$$
Der Nachkommaanteil $0.2$ ist bereits bekannt (siehe 2te Zeile). Damit ergibt sich ein periodischer Nachkommaanteil $0.1 = [0.0\overline{0011}]_2$
mit unendlicher Wiederholung der Bitfolge $[0011]_2$.
```

Für die Dezimalzahlen $0.1, 0.2,\ldots , 0.9$ ergeben sich die Binärdarstellungen:

$$
0.1 &= [0.0\overline{0011}]_2     &\; 0.6 &= [0.1\overline{0011}]_2 \\
0.2 &= [0.\overline{0011}]_2      &\; 0.7 &= [0.1011\overline{0011}]_2 \\
0.3 &= [0.01\overline{0011}]_2    &\; 0.8 &= [0.11\overline{0011}]_2 \\
0.4 &= [0.011\overline{0011}]_2   &\; 0.9 &= [0.111\overline{0011}]_2 \\
0.5 &= [0.1]_2
$$

Keine der Dezimalzahlen $0.1, 0.2,\ldots, 0.9$ außer $0.5$ lässt sich also mit endlicher
Nachkommastellenanzahl exakt binär darstellen. Diese Erkenntnis ist im praktischen
Umgang mit Computern von großer Bedeutung, z.B. bei der Konzeption numerischer Algorithmen,
bei der Spezifikation von Eingabedaten und der Interpretation berechneter Ergebnisse usw.

Auch wenn die Festkommadarstellung eine große Menge an rationalen Zahlen darstellen kann, ist sie doch im in ihrem Wertebereich
durch die Anzahl an Vorkomma-Ziffern, und in ihrer Genauigkeit durch die Anzahl Nachkommaziffern für viele Anwendungen
nicht ausreichend. Wir betrachten im folgenden ein anderes Darstellungsformat, in dem das Komma (der Punkt) zusätzlich noch
flexibel verschoben werden kann.

## Reelle Zahlen

## Gleitkommazahlen

Gleitkommazahlen (GKZ) sind eine endliche Teilmenge der rationalen Zahlen, die in einem
meistens durch Hardware festgelegten sog. Gleitkomma(zahl)format (GKZ-Format = GK-Format)
fester Speicherbreite darstellbar sind. Sie bilden ein diskretes Raster/Gitter rationaler
Zahlen in einem beschränkten Bereich. GKZ werden auch als *Fließkomma-*, *Gleitpunkt-* oder
*Fließpunktzahlen* (*floating-point numbers*) bezeichnet.
Wir bezeichnen die Menge der Gleitkommazahlen mit $\mathbb{F}$, angelehnt an den Englischen Begriff *floating point numbers*.

```{prf:definition} Gleitkommazahl
Die Menge der **Gleitkommazahlen** ist definiert als

$$
\mathbb{F} = \mathbb{F}(b, l, \underline{e}, \overline{e}) := \{x\in\mathbb{Q}\;\mid\;x=(-1)^{s_x}\cdot m_x \cdot b^{e_x}\} \subset\mathbb{Q}\subset\mathbb{R}
$$

mit $b\in\mathbb{N}, b\geq 2$ die *Basis* (= *base* = *radix*) der GKZ, $s_x\in\{0,1\}$ das *Vorzeichenbit* (= *sign*), $m_x=[0.m_1, m_2 \cdots m_l]_b$ die *Mantisse* (= *mantissa* = *significand*) mit Ziffern $m_i\in\{0,1,\ldots,b-1\}$ und $e_x\in\{\underline{e},\underline{e}+1,\ldots,\overline{e}\}$ der *Exponent* (= *exponent*) mit $\underline{e}, \overline{e} \in \mathbb{Z}$ und $\underline{e} < \overline{e}$ der kleinste/größte Exponent.
```

Wir bezeichnen mit $\mathbb{F}(b, l, \underline{e}, \overline{e})$ die Parameter der Darstellung auch als das zugehörige *GKZ-Format*. Typischerweise wird der Exponentenbereich  $[\underline{e}, \overline{e}]$ annähernd symmetrisch (zur Null) gewählt, um die Inversion/Kehrwertbildung für möglichst viele darstellbare GKZ (genähert) zu ermöglichen.

```{note}
Die Zahl $x=0$ hat in der Menge der Gleitkommazahlen keine eindeutige Darstellung, sondern kann mit einem beliebigen Vorzeichen und beliebigen Exponenten dargestellt werden, wenn als Mantisse $m_x=[0.0\ldots 0]=0$ gewählt wird. Dies bedeutet, dass die Null bei dieser (einfachen) Art der
Kodierung $2\cdot (\overline{e} - \underline{e} + 1)$ Darstellungen besitzt und insbesondere mit einem positiven oder negativen Vorzeichen versehen werden kann.
```
```{note}
Für all $x\in\mathbb{F}(b, l, \underline{e}, \overline{e})$ gilt auch $-x\in\mathbb{F}(b, l, \underline{e}, \overline{e})$.
```

Die GK-Darstellung einer Zahl ist also eine Art skalierter Festkommadarstellung: das Vorzeichen und die Mantisse definieren eine Festkommazahl und der Exponent definiert den Skalierungsfaktor $b^{e_x}$, mit dem der Festkommawert multipliziert werden muss. Da der Skalierungsfaktor eine ganzzahlige Potenz der Basis ist, bedeutet dieses Skalieren lediglich das Verschieben der Festkommaziffern um $e_x$ Stellen/Positionen nach links, wobei ein negativer Exponent natürlich das Verschieben um $-e_x$ Stellen nach rechts bedeutet.

```{prf:definition} Normalisierte und denormalisierte Zahlen

Eine GKZ bzw. Mantisse ($\neq 0$) heißt **normalisiert**, wenn ihre erste (vordere) Mantissenziffer $m_1 \neq 0$ ist,
ansonsten *unnormalisiert*.
Der Wert einer normalisierten Mantisse liegt im Intervall $[b^{-1}, 1)$, der einer unnormalisierten Mantisse ist stets $< b^{-1}$.

Eine GKZ $x\neq 0$ heißt **denormalisiert** (= *denormal(ized)* = *subnormal*), wenn ihr Exponent kleinstmöglich,
also $e_x = \underline{e}$, und ihre erste Mantissenziffer $m_1 = 0$ sind.
```

Die größte darstellbare GKZ $x_{\max}\in\mathbb{F}(b, l, \underline{e}, \overline{e})$ ist

$$
x_{\max} = 0.\underbrace{\overline{b}\overline{b}\cdots\overline{b}}_{l} \cdot b^{\overline{e}} = (1-b^{-l})\cdot b^{\overline{e}},
$$

mit $\overline{b}:=b-1$ die größtmögliche Ziffer. Die kleinste positive normalisierte GKZ $x_{\min,N}$ und die kleinste positive denormalisierte GKZ $x_{\min,D}$ sind

$$
x_{\min,N} &= 0.\underbrace{10\cdots 00}_l \cdot b^{\underline{e}} = b^{\underline{e}-1}, \\
x_{\min,D} &= 0.\underbrace{00\cdots 01}_l \cdot b^{\underline{e}} = b^{\underline{e}-l}.
$$

```{prf:example}
:label: bsp-gleitkommaformat
Im GKZ-Format $\mathbb{F}(2,3,-1,2)$ werden zur Speicherung von Zahlen 6 Bit benötigt:
- 1 Bit zur Speicherung des Vorzeichenbits $s\in\{0,1\}$,
- 2 Bit zur Speicherung des Exponenten $e\in\{-1,0,1,2\}$,
- 3 Bit zur Speicherung der Mantisse $m\in\{0,1/8,2/8,3/8,4/8,5/8,6/8,7/8\}$.
```

Es ist üblich, statt des tatsächlichen Exponentenwerts $e_x$ eine um einen sog. Bias $\beta$ verschobene
Exponentenkennung $E_x := e_x + \beta$ zu speichern, um bei der Kodierung des Exponenten
negative Werte zu vermeiden. Wir wählen den Bias zunächst so, dass der kleinste Exponentenwert $\underline{e}$
gerade durch die Null dargestellt wird, also $\beta = -\underline{e}$. Wenn wir in unserem Beispiel also
$\beta = 1$ wählen, dann werden die Exponentenwerte $\{-1, 0, 1, 2\}$ gerade auf die Exponentenkennungen
$\{0, 1, 2, 3\} verschoben. (Wie wir weiter unten sehen werden, wird der Bias in heutigen
GKZ-Systemen um 1 größer gewählt, um die Exponentenkennung $E_x = 0$ für die Null und die
denormalisierten GKZ reservieren zu können.)

In unserem Beispiel gibt es also insgesamt $2 \cdot 2^2 \cdot 2^3 = 2^6 = 64$ Möglichkeiten, ein Bitmuster
und somit eine Zahl zu bilden. Offensichtlich ist die Darstellung der GKZ nicht eindeutig,
d.h. verschiedene Werte $s_x$, $m_x$ und $e_x$ liefern nicht immer unterschiedliche Werte für die GKZ
$x = (-1)^{s_x}\cdot m_x \cdot b^{e_x}$ (vgl. {numref}`tbl-bsp-gkz`). Insbesondere existieren in diesem Format 8 Darstellungen
für die Null, je 4 für jedes Vorzeichen. Andere Zahlen besitzen $3$ (z.B. $1 / 4$ und $1 / 2$), $2$ (z.B. $1 / 8$
und $3 / 2$) oder auch nur $1$ Darstellung:

```{table} Tabelle der nichtnegativen GKZ des Formats $\mathbb{F}(2, 3, −1, 2)$
:widths: auto
:align: center
:name: tbl-bsp-gkz

| $m_x\cdot 2^{e_x}$ | 0.111  | 0.110  | 0.101  | 0.100  | 0.011  | 0.010  | 0.001  | 0.000  |
| ------------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| $e_x=-1$           | $7/16$ | $3/8$  | $5/16$ | $1/4$  | $3/16$ | $1/8$  | $1/16$ | $0$    |
| $e_x= 0$           | $7/8$  | $3/4$  | $5/8$  | $1/2$  | $3/8$  | $1/4$  | $1/8$  | $0$    |
| $e_x= 1$           | $7/4$  | $3/2$  | $5/4$  | $1$    | $3/4$  | $1/2$  | $1/4$  | $0$    |
| $e_x= 2$           | $7/2$  | $3$    | $5/2$  | $2$    | $3/2$  | $1$    | $1/2$  | $0$    |
```

### Absoluter und relativer Abstand5

Wenn man die nichtnegativen GKZ des Formats $\mathbb{F}(2, 3, −1, 2)$ auf einer Zahlengerade anordnet,
dann ergibt sich ein Muster (GKZ-Raster), das für GKZ-Formate typisch ist:

```{figure} images/gkz-raster1.png
:name: fig-gkzraster1

Nichtnegative GKZ des Formats $\mathbb{F}(2, 3, −1, 2)$.
```

Wie man an dem oben abgebildeten GKZ-Raster in {numref}`fig-gkzraster1` sieht, sind die GKZ, zumindest die normalisiert
darstellbaren, grob gesehen logarithmisch gleichverteilt, d.h. ihre relative Dichte (oder ihr
relativer Abstand) ist global gesehen überall ungefähr gleich -- in Wirklichkeit ist der absolute
Abstand benachbarter GKZ aber von einem Exponentensprung zum nächsten konstant und
springt dann um den Faktor $b$. Man nennt GKZ-Raster deshalb auch *semilogarithmisch*.

Während der relative Abstand benachbarter GKZ (und somit auch der relative Fehler bzw.
die Genauigkeit der Ergebnisse elementarer Rechenoperationen) im gesamten Bereich der normalisiert
darstellbaren GKZ maximal um den Faktor $b$ schwankt, nimmt dieser unterhalb der
kleinsten normalisiert darstellbaren GKZ bis zur Null rapide zu. Im Bereich dieser denormalisierten
GKZ bleibt der absolute Abstand benachbarter GKZ bis zur Null konstant, d.h. der
relative Abstand/Fehler wächst bis auf 1 (oder 100%), da die zweitkleinste denormalisierte GKZ
doppelt so groß ist wie die kleinste.


```{prf:definition} Unit in the last place
Der Begriff **Einheit in der letzten Stelle** (der Mantisse einer GKZ), bzw. **unit in the last place** (**ulp**) gibt das Gewicht der letzten Mantissenziffer einer GKZ $x\neq 0$ an.

$$
\operatorname{ulp}(x) := b^{e_x-l}\qquad\text{ für }x\neq 0.
$$
```

```{prf:lemma}
Die $\operatorname{ulp}(x)$ einer GKZ $x\not\in \{0, x_{\max}\}$ entspricht dem Abstand dieser GKZ zu ihrem betragsgrößeren Nachbarn in der Menge der Gleitkommazahlen.
```
```{prf:proof}
Sei $x\neq 0$ eine GKZ und $\hat{x}$ die nächst größere GKZ. Ist $\hat{x}=0$, dann muss $x=x_{\min,D}$ und die Aussage folgt sofort. Wir nehmen also an, dass $\hat{x}\neq 0$. Dann sind die Vorzeichen beider GKZ gleich und es folgt

$$
|\hat{x} - x| &= |m_{\hat{x}} \cdot b^{e_{\hat{x}}} - m_x \cdot b^{e_x}| \\
              &= 0.\underbrace{00\cdots 01}_{l} \cdot b^{e_x} = b^{e_x-l}.
$$
```

```{note}
Da das *ulp* nur von der Mantissenlänge $l$ (die für ein gegebenes GK-Format fest ist) und dem Exponenten $e_x$ der betrachteten GKZ $x$ abhängt, ist es für alle GKZ mit demselben Exponentenwert identisch, d.h. diese GKZ sind in einem GK-Raster äquidistant angeordnet. Dies gilt auch für denormalisierte GKZ, die alle denselben Exponenten $\underline{e}$ und den Abstand $b^{\underline{e}-l}$ zu ihren GK-Nachbarn haben.
```

Um den Begriff des GK-Nachbarn zu präzisieren, definieren wir den Vorgänger und den Nachfolger einer GKZ $x \neq 0$ wie folgt:

```{prf:definition} GK-Nachbarn
Der **Vorgänger** (= *predecessor*) einer GKZ $x\not\in\{0,-x_{\max}\}$ ist definiert als

$$
  \operatorname{pred}(x) := \left\{\begin{array}{ll}
    x - \frac{\operatorname{ulp}(x)}{b} & \text{ false }x=b^k\text{ mit }k\in\mathbb{Z}\text{ und normalisiert}, \\
    x - \operatorname{ulp}(x)            & \text{ sonst (auch denormalisiert)}.
  \end{array}\right.
$$

Der **Nachfolger** (= *successor*) einer GKZ $x\not\in\{0,x_{\max}\}$ ist definiert als

$$
  \operatorname{succ}(x) := \left\{\begin{array}{ll}
    x + \frac{\operatorname{ulp}(x)}{b} & \text{ false }x=-b^k\text{ mit }k\in\mathbb{Z}\text{ und normalisiert}, \\
    x + \operatorname{ulp}(x)            & \text{ sonst (auch denormalisiert)}.
  \end{array}\right.
$$

Die jeweils erstgenannten Sonderfälle (mit Schrittweite $\frac{\operatorname{ulp}(x)}{b}$) treten also nur auf, wenn man
von einer GKZ, deren Betrag eine ganzzahlige Potenz der Basis ist, zu ihrem betragskleineren
GK-Nachbarn geht; ansonsten ist ein GK-Nachbar immer $\operatorname{ulp}(x)$ entfernt.
```

Mit dem Begriff $\operatorname{ulp}$ eng verbunden ist das sog. **Wilkinson-$\varepsilon$**, welches nach dem englischen
Numeriker und Computerpionier *James H. Wilkinson*, der mit seinem 1963 erschienenen, sehr
einflussreichen Buch "Rounding Errors in Algebraic Processes" die Theorie der Fehlerabschätzung
bei Gleitkommarechnung begründete. Er erhielt 1970 unter anderem für diese Arbeit und
für seine maßgebliche Beteiligung an der Entwicklung mehrerer englischer Computer seit den
späten 1940er Jahren (zu Beginn noch gemeinsam mit Alan Turing) den renommierten ACM
Alan M. Turing Award (quasi der Nobelpreis der Informatik).

```{prf:definition} Wilkonson-$\varepsilon$
:label: dfn-wilkonson-epsilon

Das Wilkinson-$\varepsilon$ gibt den *maximalen relativen Abstand* benachbarter normalisierter GKZ
und somit auch den *maximalen relativen Fehler*, den eine arithmetische Grundoperation (durch
Rundung des exakten Ergebnisses in das GK-Format) machen darf, an:

$$
\varepsilon := b^{1-l}
$$
```

Dieser maximale relative Abstand tritt immer direkt nach einem Exponentensprung (siehe auch
weiter oben) auf, also zwischen $b^k$ und $b^k + \operatorname{ulp}(b^k)$ mit $k\in\mathbb{Z}$, während er direkt davor fast
um den Faktor $b^{-1}$ kleiner ist. Das Wilkinson-$\varepsilon$ ist also ein Maß für die Granularität eines
GK-Rasters und somit für die maximal erreichbare Genauigkeit beim Rechnen in diesem GK-Format.

Wie man leicht sieht, ist $\varepsilon = \operatorname{ulp}(1)$, da die Zahl $1$ als die GKZ $[0.100\cdots 0]_b \cdot b^1$ dargestellt wird,
also mit dem Exponentenwert $1$. Anders ausgedrückt ist das Wilkinson-$\varepsilon$ gerade der Abstand
zwischen $1$ und der nächstgrößeren GKZ (die nächstkleinere GKZ ist nur $\varepsilon / b$ von $1$ entfernt).

### Normalisierung
