---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Julia 1.11
  language: julia
  name: julia-1.11
---

# Rekursion

In den Vergangenen Kapiteln haben wir ein grundsätzliches algorithmisches Prinzip schon kennen gelernt: die Rekursion. Es basiert darauf, dass das Ergebnis eines Problems auf ein gleiches oder ähnliches Problem kleiner Größe zurück geführt wird, bis man ein minimales Problem direkt lösen kann. Im [Multiplikationsalgorithms](#sec-integer-multiplication) konnten wir das Produkt mit dem Faktor $1$ direkt auswerten und größere Faktoren mit Hilfe der Rekursionsvorschrift $n\cdot a = (n-1)\cdot a + a$ auf die Multiplikation mit einer kleineren Zahl zurückführen. In der Implementierung haben wir dann gesehen, dass die Funktion `multiply()` sich selber aufruft.

## Türme von Hanoi

Wir betrachten noch ein weiteres Beispiel, das die Rekursionsprinzipien illustrieren soll:

```{prf:example} Die Türme von Hanoi
:label: bsp-tuerme-von-hanoi

Ein Rätsel oder Spiel, das man den Hindu Pristern im größen Tempel von Benares zuschreibt, basiert darauf, dass man einen Stapel von Scheiben unterschiedlicher Größe von einer Position A auf einer Positions B bringen soll unter Ausnutzung einer dritten Position C. Dabei gilt es nur wenige Regeln zu beachten: 1. Die Scheiben müssen immer der Größe nach sortiert sein, d.h. kleinere Scheiben liegen immer über größeren Scheiben, und 2. es darf immer nur die oberste Scheibe eines Stapels bewegt werden.

Betrachten wir die Situation wie in {numref}`fig-tuerme-von-hanoi` mit 3 Scheiben auf Stapel A, die auf Stapel B bewegt werden sollen. Wir beschreiben die Bewegung einfach als einen Pfeil $A\to B$, um auszudrücken, dass die oberste Scheibe von $A$ auf den Stapel $B$ bewegt werden soll.
Eine Lösung des Spiels sieht nun folgendermaßen aus:

$$
A &\to B; \\
A &\to C; \\
B &\to C; \\
A &\to B; \\
C &\to A; \\
C &\to B; \\
A &\to B.
$$
```
```{exercise}
Erweitern Sie das das Beispiel um eine 4te Scheibe. Wieviele Schritte werden benötigt, um den Turm von $A$ nach $B$ zu verschieben? Die Hindu Prister hatten angebich Türme von 64 Scheiben. Wie lange wird die Lösung dieses Spiels wohl dauern?
```

```{figure} images/tuerme-von-hanoi.png
:name: fig-tuerme-von-hanoi
Beispielkonfiguration der Türme von Hanoi mit 3 Scheiben.
```

Wie kann dieser Algorithmus in ein rekursives Verfahren überführt werden? Nehmen wir für einen Moment an, dass wir mehr als eine Scheibe auf einmal bewegen könnten, z.B. alle Scheiben bis auf die unterste. Dann könnte man die Lösung in drei Schritten aufschreiben:

```{prf:algorithm} Türme von Hanoi
:label: alg-tuerme-von-hanoi

*Eingabe:* Anzahl Scheiben $n$ auf Stapel A, Zielstapel B, Hilfsstapel C

1. Bewege den Stapel der obersten $n-1$ Scheiben von Position A nach Position C.
2. Bewege die oberste Scheibe von A nach B.
3. Bewege den Stapel der obersten $n-1$ Scheiben von Position C nach Position B.
```

Damit haben wir das Problem $n$ Scheiben zu bewegen reduziert auf ein Problem $n-1$ Scheiben zu bewegen. Außerdem wissen wir wie man eine einzelne Scheibe bewegt.

Wir können dies auch in Julia Code ausdrücken. Dabei wird eine Bewege-Operation durch eine Ausgabe $A\to B$ realisiert. Wir schreiben eine Methode `move()`, die als Eingabe nur die Information bekommt, wie viele Scheiben zu bewegen sind, von welcher zu welcher Position und welcher Hilfsstapel verwendet werden kann.
```{code-cell}
"""
  move(n, X, Y, Z)

Move the top ``n`` rings from position ``X`` to ``Y`` using ``Z``.
"""
function move(n, X,Y,Z)
  if n == 1
    println("$(X) -> $(Y)")
  else
    move(n-1, X, Z, Y)
    println("$(X) -> $(Y)")
    move(n-1, Z, Y, X)
  end
end

move(3, "A", "B", "C")
```

Schaut man sich nun an, wie die Funktion sich selbst aufruft, muss man beachten, dass die Parameter `X`,`Y` und `Z` in jedem Aufruf einen anderen Wert haben könnten. Beim ersten Aufruf übergeben wir die Bezeichnungen der Stapel, "A", "B", und "C", aber schon beim ersten rekursiven Aufruf bekommt Y den Wert "C" und Z den Wert "B":

```{code-cell}
function print_move(n, X,Y,Z)
  println("move($(n),$(X),$(Y),$(Z))")
  if n > 1
    print_move(n-1, X, Z, Y)
    print_move(n-1, Z, Y, X)
  end
end

print_move(3, "A", "B", "C")
```

Jeder Aufruf der Funktion, muss sich "merken" was ihre Parameter-Werte waren, und auch zu welchem Zustand es zurückkehren muss, nachdem die eigenen Schritte abgearbeitet sind. Um dies zu realisieren, werden die Daten (Parameter, lokale Variablen, Ergebnis) zusammen mit einer Ursprungsaddresse auf einen *Laufzeitstapel* (= *runtime stack*) abgelegt, sobald eine Funktion aufgerufen wird. Ist ein Funktionsaufruf beendet, werden die Daten wieder vom Stapel genommen und der freigewordene Speicher kann durch den nächsten Funktionsaufruf wieder überschrieben werden. Wir bezeichnen die maximale Anzahl an Einträgen auf diesem Stapel, zugehörig zu der Funktion (hier `move`), als Rekursionstiefe.

```{note}
Die Rekursionstiefe im Beispiel der "Türme von Hanoi" ist durch die Größe des Aufgangsstapels definiert.
```

### Korrektheit eines rekursiven Algorithmus

Wie können wir zeigen, dass der rekursive Algorithmus korrekt ist?

Wir gehen davon aus, dass die Operation `move(n,X,Y,Z)` mit einem $n\geq 1$ und $X\neq Y\neq Z$ aufgerufen wurden.

1. Der Algorithmus terminiert in einer endlichen Anzahl an Schritten. Denn, jeder Aufruf der Operation `move()` impliziert höchstens zwei weitere aufrufe mit jeweils um 1 reduziertem $n$. Es gibt also $1 + 2 + 4 + 8 +\ldots = \sum_{m=0}^{n-1} 2^m$ Aufrufe insgesamt und diese Zahl ist mit $n<\infty$ auch endlich.
2. Der Algorithmus produziert einen validen Move eines Stapel mit $n$ Scheiben von X nach Y unter Hilfe von Z.

Für den 2. Teil des Beweises kann man nun ein Induktionsargument verwenden. Dafür müssen wir noch etwas klarer Spezifizieren, was wir mit einem "validen Move" meinen. Die Idee des Induktionsbeweises ist, dass wir eine Aussage $A(n)$ dadurch zeigen, dass wir sie für $A(1)$ verifizieren, dann annehmen, dass sie für alle $A(n-1)$ gilt, um dann im Induktionsschritt von $A(n-1)$ auf die Aussage $A(n)$ schließen. Die "Aussage" die hier zugrunde gelegt werden kann ist folgende:

*$A(n)$: Die $n$ kleinsten Ringe des Systems werden korrekt und in endlichen Schritten von X nach Y bewegt (potenziell unter Zuhilfnahme von Z), wobei zu jeder Zeit nur kleinere auf größeren Scheiben liegen und eine Scheibe nach der anderen bewegt wird und alle anderen Scheiben, außer den zu bewegenden, nicht berührt werden.*

Man prüfe leicht nach, dass der Induktionsanfang $A(1)$ erfüllt ist. Unter Zuhilfnahme der Induktionshypothese $A(n-1)$ beweise man dann dass $A(n)$ gilt. Dabei muss insbesondere darauf geachtet werden, dass alle Bedingungen der Aussage durchgängig erfüllt bleiben.


## Memoisation

Rekursion ist oftmals eine sehr schöner Lösungsansazt zu einem Problem. Das Prinzip, dass die Funktion sich selber aufruft, und dabei z.B. den Laufzeitstack weiter füllt, hat auch einen weiteren Nachteil: die tieferen Aufrufen wissen i.d.R. nicht wie sie aufgerufen wurden und können mit der Aufrufshierarchie auch nicht "interagieren". Das nächste Beispiel soll diese Problem verdeutlichen:

```{prf:example} Fibonacci Zahlen
:label: bsp-fibonacci

Eine Folge von natürlichen Zahlen, bei der jede Zahl die Summe der beiden Vorgänger Zahlen darstellt, wird Fibonacci-Folge genannt. Sie kann rekursive folgendermaßen definiert werden:

$$
f_n := \left\{\begin{array}{ll}
  1 & \text{ wenn }n \in \{1,2\}, \\
  f_{n-1} + f_{n-2} & \text{ sonst}.
\end{array}\right.
$$

wobei $f_n$ ($n\geq 1$) den $n$-ten Eintrag der Folge darstellt.
```

Ausgedrückt in Julia Code lautet der rekursive Algorithmus
```{code-cell}
function fibonacci(n)
  println("fibonacci($(n))")
  if 0 < n <= 2
    return 1
  else
    return fibonacci(n-1) + fibonacci(n-2)
  end
end

[fibonacci(n) for n in 1:5]
```

Wie man in der Ausgabe der Funktionsaufrufe sehen kann, werden einige Fibonacci-Zahlen $f_n$ mehrfach berechnet. Eine Lösung besteht darin, sich die Zwischenergebnisse zu merken. Das bezeichnet man auch als *Memoisation*. Die erste Variante dieser Technik, auf die Fibonacci-Folgen Berechnung angewendet, nutzt ein zusätzliches Speicherargument, ein *Array* dass auf einen neutralen Wert, z.B. `0`, initialisiert ist -- eine art *Lookup-Tabelle*:

```julia
function fibonacci_memo(n, lookup)
  if lookup[n] == 0
    lookup[n] = fibonacci(n-1) + fibonacci(n-2)
  end
  return lookup[n]
end

function fibonacci2(n)
  if n <= 2
    return 1
  end
  lookup = [[1,1]; zeros(Int64,n-2,1)] # [1,1,0,0,0,...,0]
  return fibonacci_memo(n, lookup)
end
```

## Iterativer Algorithmus

Eine Alternative die verschiedene Nachteile der rekursiven Algorithmen vermeidet, ist die Transformation in einen iterativen Algorithmus. I.A. ist dies eine komplizierte Aufgabe, aber es gibt einige Fällt, wo es direkt durchgeführt werden kann.

Für die Fibonacci-Folge ist die Transformation in einen iterativen Algorithmus leicht. Man fängt einfach bei den ersten beiden Fibonacci-Zahlen $[1,1]$ an und geht dann mit $n$ weiter:
```{code-cell}
function fibonacci2(n)
  f1 = 1
  if n == 1
    return f1
  end

  f2 = 1
  if n == 2
    return f2
  end

  for i in 3:n
    f1, f2 = f2, f1+f2
  end
  return f2
end

[fibonacci2(n) for n in 1:5]
```

Auch der rekursive Algorithmus der "Türme von Hanoi" lässt sich ersetzen durch eine iterative Verfahrensvorschrift:
```{prf:algorithm} Türme von Hanoi iterativ
:label: alg-turme-von-hanoi-iterativ

Wiederhole die folgenden Schritte bis vor Schritt 2. alle Scheiben korrekt auf einem anderen Stapel positioniert wurden:

1. Bewege die kleinste Scheibe von ihrer aktuellen Position auf den Stapel zu ihrer rechten. Wenn der letzte Stapel erreicht wurde, starte wieder ganz links.
2. Mache die einzige mögliche Bewegung einer andere Scheibe (die nicht die kleineste Scheibe ist).
```

### Endrekursion

```{prf:definition} Endrekursiv
:label: def-endrekursiv
Wir bezeichnen eine rekursive Funktion als **endrekursiv** (= *tail recursive*) wenn der rekursive Funktionsaufruf die letzte Anweisung der Funktion ist.
```

Diese Form von rekursiven Algorithmen (oder Funktionen) lassen sich sehr einfach in eine iterative Vorschrift überführen. Die Anforderung ist allerdings manchmal nur über einen zusätzlichen Parameter oder ein Umschreiben des Algorithmus zu realisieren.

Betrachten wir nochmal den Multiplikationsalgorithmus
```julia
function multiply2(n,a)
  if n == 1
    return a
  end
  result = multiply2(n >> 1, a << 1) # half n, double a
  if n % 2 != 0                      # n is odd
    result = result + a
  end
  return result
end
```

Dies ist noch nicht in der Endrekursionsform, denn nach der rekursiven Auswertung von `multiply2(n>>1,a<<1)` wird das Ergebnis noch mit `a` addiert.

```{tip}
Manchmal ist es einfacher *mehr* zu tun, als *weniger*.
```

Anstestelle, dass wir direkt `n\cdot a` ausrechnen, wollen wir die Summe `r + n\cdot a` auswerten, also das Produkt auf einen Wert aufaddieren. Man nennt diese Operation auch *multiply-accumulate*. Sie ist in vielen Algorithmen anzutreffen. Geschrieben als Julia Code ergibt sich

```julia
function multiply_acc(r, n, a)
  if n == 1
    return r + a
  end
  if n % 2 != 0
    return multiply_acc(r + a, n>>1, a<<1)
  else
    return multiply_acc(r, n>>1, a<<1)
  end
end
```
Die beiden rekursiven Aufruve unterscheiden sich nur im ersten Argument - dem Accumulator. Diese kann auch ohne rekursiven Aufruf zuerst aktualisiert werden
```julia
function multiply_acc2(r, n, a)
  if n == 1
    return r + a
  end
  if n % 2 != 0
    r = r + a
  end
  return multiply_acc2(r, n>>1, a<<1)
end
```
Wir können dies noch ein klein Wenig weiter optimieren. Die Operation `r + a` wird in zwei Fällen, `n == 1` oder `n` ungerade durchgeführt. Da `1` auch ungerade ist und nur genau einmal auftritt in der Rekursion, kann man diese beiden Abfragen kombinieren:
```julia
function multiply_acc3(r, n, a)
  if n % 2 != 0
    r = r + a
    if n == 1
      return r
    end
  end
  return multiply_acc3(r, n>>1, a<<1)
end
```

Die Varianten `multiply_acc2()` und `multiply_acc3()` sind beide schon *endrekursiv*. Geht man aber noch einen Schritt weiter, lässt sich die Transformation in einen iterativen Algorithmus noch leichter durchführen:

```{prf:definition} Strikt endrekursiv
:label: dfn-strictly-endrecursive

Eine **strikt endrekursive** Funktion $f$ hat als endrekursiven Aufruf die Funktion selbst mit den Argumenten die den formalen Parametern von $f$ entsprechen.
```
Im Beispiel `multiply_acc3()` werden für `n` und `a` allerdings andere Werte übergeben. Dies kann aber leicht in eine *strikt endrekursive* Form gebracht werden:

```julia
function multiply_acc4(r, n, a)
  if n % 2 != 0
    r = r + a
    if n == 1
      return r
    end
  end
  n = n>>1
  a = a<<1
  return multiply_acc4(r, n, a)
end
```

Eine solche strikt endrekursive Implementierung lässt sich nun direkt in ein iteratives Programm überführen, indem man die Rekursion durch eine `while true` Schleife ersetzt:

```{code-cell}
function multiply_acc5(r, n, a)
  while true
    if n % 2 != 0
      r = r + a
      if n == 1
        return r
      end
    end
    n = n>>1
    a = a<<1
  end
end

function multiply3(n, a)
  if n == 1
    return a
  end
  return multiply_acc5(a, n-1, a) # a + (n-1)*a
end

multiply3(5,4)
```

````{note}
Die Implementierung `multiply3()` ist schon recht gut, außer für den Fall dass $n=2^m$. Durch die Subtraktion von 1 in $n-1$ bekommen wir eine binäre Repräsentation in der alle Ziffern $1$ sind, was dem worst-case Szenario des Algorithmus entspricht. Diesen Fall kann man einfach dadurch auflösen, dass man die Operation des halbierens und verdoppelns herauszieht und explizit durchführt:
```julia
function multiply4(n, a)
  while n % 2 == 2   # Solange n eine gerade Zahl ist
    n = n>>1
    a = a<<1
  end
  if n == 1
    return a
  end
  # Weil nun (n-1) eine gerade Zahl ist, muss n-1 != 1
  return multiply_acc5(a, (n-1)>>1, a<<1)
end
```
````

```{hint}
Moderne CPUs implementieren die *multiply-accumulate* Operation auch als eine Instruktion, bei der das Zwischenergebnis der Multiplikation $n\cdot a$ in Gelitkommaarithmetik nicht erst gerundet und dann auf den Accumulator $r$ aufaddiert wird, sondern erst nach der kombinierten Operation das Ergebnis in das Zielformat gerundet wird. Diese Operation bezeichnet man dann auch als *fused-multiply-add* (FMA) Operation. In Julia can die Operation mittels `muladd(n, a, r)`, bzw. `fma(n, a, r)` durchgeführt werden.
```

## Rekursive Datenstrukturen

Wie auch Algorithmen können Datenstrukturen eine rekursive Struktur haben. Die "Rekursion" besteht darin, dass die Datenstruktur eine "kleinere" Version von sich selbst enthält. die Operationen die dann auf diesen Datenstrukturen durchgeführt werden, sind meist auch rekursiv implementiert. Rekursiv definierte Datenstrukturen können häufig dynamisch wachsen oder ihre Struktur verändern

Ein erstens Beispiel eine rekursiv definierten Datenstruktur ist eine *einfach verkettete Liste*. Die Einträge (*nodes*) der Liste kann man sich vorstellen als einen Werte und eine "Referenz" auf den nächsten Eintrag. Das entspricht der *Rekursionsvorschrift*. Die "Abbruchbedingung" realisiert man dadurch, dass die Referenz auf einen speziellen Eintrag zeigen darf, der das Ende der Liste markiert. Dieses Ende wird manchmal als *nil* (not-in-list) oder *null* (ein Zeiger auf die 0-Addresse) bezeichnet.

````{prf:example} Einfach verkettete Liste
In Julia lässt sich eine Listen Datenstruktur für `Float64` Werte relaisieren über ein `struct`. Die beiden möglichen Zustände des nächsten Entrags wird über ein `Union` aus der Liste selbst und dem Spezialwert `nothing` gebildet:
```julia
mutable struct List
  head::Float64
  tail::Union{List, Nothing}
end

# Füge einen neuen Eintrag mit `value` and das Ende der Liste an
function push!(l::List, value::Float64)
  if isnothing(l.tail)   # Abbruchbedingung
    l.tail = List(value, nothing)
  else
    push!(l.tail, value) # rekursiver Aufruf
  end
end

l = List(1.0, List(2.0, List(3.0, List(4.0, nothing))))
push!(l, 5.0)
```
````

````{hint}
Eine Alternative zum `union` Ansatz ist es, das nächste Element auf sich selbst zeigen zu lassen. Dafür ist es notwendig den Spezialfall, dass es kein `tail` gibt, als "Constructor" hinzuzufügen:

```julia
mutable struct List2
  head::Float64
  tail::List2

  List2(head::Float64) = (l=new(head); l.tail=l; l)
  List2(head::Float64, tail::List2) = new(head,tail)
end
l = List2(1.0, List2(2.0, List2(3.0, List2(4.0))))
l.tail.tail.tail.tail = List2(5.0)
```
````