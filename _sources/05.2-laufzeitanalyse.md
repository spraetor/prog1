---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Julia 1.11
  language: julia
  name: julia-1.11
---

# Laufzeitanalyse

Wie lange ein Algorithmus zur Lösung eines gegebenen Problems tatsächlich braucht, hängt von vielen Faktoren ab. Die a-priori Komplexitätsanalyse gibt uns i.d.R. nur eine Aussage über das asymptotische Verhalten, also für große Eingabedaten. Für kleine $n$ kann es bedeuten, dass ein Algorithmus mit einer Laufzeitkomplexität von $\mathcal{O}(n)$ schneller ist, als ein Algorithmus mit Komplexität $\mathcal{O}(\log{n})$. Eine Grundprinzip der Programmierung lautet "teste!" und "messe!". Die theoretische Korrektheit eines Algorithmus verhindert nicht, dass wir Programmierfehler in den Code einbauen. Deswegen sollte man Tests und Überprüfungen in den Code einbauen. Siehe auch Kapitel "Debugging". Die reale Laufzeit eines Programms hängt von der CPU, der konkreten Zusammensetzung der Eingabedaten, der Datentypen, aber auch der Fähigkeit des Compilers den Code zu optimieren, ab Deswegen sollte man Implementierungen nicht nur hinsichtlich ihrer theoretischen Komplexität, sondern auch ihrer praktischen Laufzeit vergleichen.

## Zeitmessung und Benchmarking

Der einfachste Weg zu messen, wie schnell ein Programm ist, besteht in dem `@time` macro, welches die Zeit zur Ausführung des Codes misst und die Anzahl Speicherallokationen zurückgibt.

```{code-cell}
sum_abs(vec) = sum(abs(x) for x in vec);
v = rand(100);

@time sum_abs(v); # Inaccurate, note the >99% compilation time
@time sum_abs(v); # Accurate
```

```{hint}
Julia Code wird bei der ersten Ausführung erst kompiliert, also in Maschinencode übersetzt. Diese Übersetzung kann selbst auch einige Zeit in Anspruch nehmen. Das sollte man beim Messen von Zeiten mit berücksichtigen und evtl. die Messung mehrfach durchführen.
```

Beim Messen der Laufzeit einer Funktion oder eines Code Abschnitts muss man auch berücksichtigen, dass die Ausführungszeit auch von anderen Faktoren beeinflusst werden kann, nicht zuletzt der aktuellen Auslastung des Computers, oder ob die CPU für diese Operationen schon "warm gelaufen" ist.

Eine Alternative zum `@time` macro, welches den Code nur genau einmal ausführt und dabei die Messung durchführt, ist das Paket [BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl). Diese Sammlung von Hilfsfunktionen zur Code Analyse bietet z.B. die Macros `@btime` und `@benchmark`, die analog zu `@time` vor eine Anweisung gestellt werden können um deren Laufzeit zu bestimmen. Dabei wird der Code u.U. mehrfach ausgeführt, um genauere Messung durchführen zu können.

```{code-cell}
using BenchmarkTools
sum_abs(vec) = sum(abs(x) for x in vec);
v = rand(100);

@btime sum_abs(v); # already accurate
@benchmark sum_abs(v)
```